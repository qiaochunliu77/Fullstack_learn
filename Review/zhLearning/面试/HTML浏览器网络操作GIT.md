## 一、计算机网络

### 1.http与https区别

```\
http相当于在网络上裸奔，https就是穿了衣服。

http在传输数据的时候是明文的		https传输数据是经过SSL加密的
安全性低						  安全性高
不需要ca证书，成本低				  需要ca证书，需要一定的费用
80端口						   443端口
http无状态连接
```

### 2.七层/四层/五层协议

![七层协议](D:\Note\笔记图片\七层协议.png)

- 应用层： DNS/HTTP/FTP/SMTP 
- 运输层：TCP/UDP

### 3.输入url到实现页面的过程

1. DNS解析，把域名解析成IP地址
2. 客户端和服务端建立连接
3. 客户端发起HTTP请求
4. 服务器处理请求并返回数据
5. 浏览器接收数据并解析
6. 断开连接

### 4.base64和url的区别

```
标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式.
```

### 5.base64

```
特点：
	1.便于网络传输
	2.不可见性
区分：
	1.base64是编码(encodeing) 而不是加密(encryption)
应用
	1.图片存储是2进制的，而不是文本形式，要传输他的话，要将2进制转为文本形式，这个时候就可以用base64
```

### 4.HTTP状态码及其含义

- `1xx`:状态信息码
  - `100 continue` 继续
- `2xx`: 成功状态码(表示正常处理)
  - 200 OK
  - 201 请求成功并且创建了服务器资源
  - 202 服务器接受请求，但并未处理
  - 204 `No Content`成功但没有数据返回
- `3xx`重定向
  - `301 Moved Permanently` 永久重定向
  - `302 Found` 临时重定向
  - `304 Not Modified` 资源找到，但未符合条件
- `4xx` 客户端错误
  - `400 Bad Request` 服务器无理解请求的格式，不要再次发起请求
  - `401 Unauthorized` 未授权(未登录，无token...)
  - `403` 禁止访问
  - `404` 找不到与URI匹配的资源
- `5xx` 服务器错误
  - `500 Internal Server Error` 最常见的错误
  - `503  Service Unavailable ` 服务器暂时无法处理请求

### 5.HTTPS加密过程

```
原理->过程

1.客户端向服务器发起HTTPS请求
2.服务器创建公钥私钥，将包含公钥的数字证书发送给客户端
3.客户端对证书进行验证，验证通过后公钥将密钥进行加密
4.客户端将加密过后的密钥发送给服务器
5.服务器用自己的私钥对密钥进行解密
6.之后就通过对称性加密的方式进行加密通信
```

### 6.HTTP缓存

```
强缓存：
	HTTPCache-Control首部和Expries首部，给每个文档添加一个过时日期，浏览器再次发起请求的时候，就会以当前时间和过期时间进行比对，没过期，命中，过期，就去服务器请求新鲜的数据.
	Cache-Control: max-age:可以设置最大使用事件，
	Expires:设置一个过期的日期，但是修改客户端的事件可以影响命中缓存，优先用cache
	
协商缓存：
	资源到期了，并不意味资源发生改变，没改变就无需再次发起请求。客户端和服务端可以通过某种验证机制去判断当前请求是否可以使用缓存。所以第一次请求的时候浏览器就会把响应头部的缓存标识保存起来。再次请求就会带上这个头部。服务器验证可用，就是304，不可用就是200
	
	Last-modified/If-Modified-Since：Last-modified服务端资源最后修改时间，由服务器响应给浏览器，浏览器将它保存为If-Modified-Since。再次发起请求就会比对这两个，一样就表示没修改过，返回304。不一样就是修改过了。返回200。
	
	Etag/If-None-Match：Etag是服务器生成的hash字符串，表示文件唯一标识符，在请求时由服务器发送给浏览器，浏览器保存为If-None-Match，再次发起请求时，会进行对比，一样就304，不一样200了
	
	区别：
		Etag精确度比Last-Modified高，因为修改时间变了，但是你内容没变，所以Etag更好
```

### 7.DNS运行过程，DNS性能优化的方法？

- **DNS作用**

- 把域名解析成相应的ip地址

- **DNS过程**

- 1.**递归查询**

  - ![1584711632672](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1584711632672.png)
  - 1.输入 **域名**后，**客户端**向**本地DNS服务器**要该域名的**IP地址**。
  - 2.**本地DNS服务器**没有，本地DNS服务器找**根域名服务器**要.
  - 3.根域名服务器没有，根服务器找A顶级域名服务器要，逐级向下找
  - 4.找到后把该域名逐级返回到**客户端**，并保存到缓存，以备下一次使用

- 2.**迭代查询**

  - ![1584712482251](C:\Users\邱\AppData\Roaming\Typora\typora-user-images\1584712482251.png)
  - 全是客户端进行询问

- **总结**

  - 输入域名:arrow_right:操作系统检查本地host文件是否有映射关系 false？ :arrow_right: 客户端向本地DNS发起查询 :arrow_right: 采用递归查询或者迭代查询.

- **DNS优化**

  - 减少`DNS`请求数量

    - DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表等的主机名，减少不同的主机名就可以减少DNS查找

  - 缩短`DNS`请求时间

    - 预加载

      - `DNS  Prefetch`让具有此属性的域名不需要用户点击链接就可以在后台解析，则域名解析和内容载入是串行的网络操作，减少等待时间.

      - ~~~html
        <link rel="dns-prefetch" href="//atanx.alicdn.com">
        ~~~

### 8.HTTP0.9/1.0/1.1/2.0

```
1.HTTP0.9:
	就是请求+响应的模式，tcp三次握手连接+四次挥手断开连接
	
2.HTTP1.0
	1.在HTTP1.0里面就可以展示多种文件类型，js，css，图片，视频，声音；
	2.在HTTP1.0里面可以设置请求头，响应头可以满足多种类型的数据传输
	3.accept：text/html accept-encoding：gzip， accept-Charset: ISO-8859-1,utf-8
	4.但是每一次请求数据都得进行一次连接和断开连接，消耗性能
	5.缓存机制，状态码，用户代理（客户端基础信息）

3.HTTP1.1
	1.持久化连接（默认开启）：多次请求数据则不需要断开连接；连接一次可以进行多次请求响应；
	2.缺点：队头阻塞：只能上一次请求响应完成才会进行下一次请求；那么就有可能阻塞后面的请求
	3.引入Cookie：
	4.问题：对带宽的利用率低（tcp启动慢，开启多条tcp连接，队头阻塞）

4.HTTP2.0
	0.原因：tcp会竞争带宽，队头阻塞
	1.多路复用解决TCP竞争：就是一个域名只是用一个tcp长连接去传输数据，这样就不会竞争
	2.解决队头阻塞：正在执行的请求卡住就阻塞后面的，所以事先了资源并行请求，不按照顺讯返回，谁好了谁返回
	
	3.头部压缩：对响应头请求头进行了压缩，虽然单个头部不大，但是在大项目里面有几百个资源，如果把它们压缩到原来的20%，那也能提高很多性能
	
	4.设置请求的优先级，有些比较重要希望可以先对他进行请求
```

### 9.tcp和udp的区别

```
1.TCP 面向连接的			UDP是无连接的
2.TCP安全性高			 UDP安全性低
3.效率低				  效率高
```



### 10.503

## 二、HTML

### 1.H5标签

```
header/footer/article/nav/section/video/audio/canvas
```

### 2.get和post

```
浏览器：
	get用于请求资源		post用于提交表单
	get参数url可见		 post参数不可见
	get请求可以缓存		post请求不可以缓存
	get数据一般2-4k		 post请求传输数据大小php.inis设定
	
```

### 3.post数据类型

```
1.application/x-www-form-urlencoded(最常见)
	原生表单，不设置enctype，就用这种方式
	
2.multipart/form-data(常用)
	必须让表单的enctype等于multipart/form-data
	
3. application/json

4.text/xml
```

### 4.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？

- 行内元素有：`a b span img input select strong`
- 块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4… p`
- 空元素： ` <br> <hr> <img> <input> <link> <meta> ` 
- 行内元素不可以设置宽高，不独占一行
- 块级元素可以设置宽高，独占一行 

### 5. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

- `!DOCTYPE html`位于文档的最前面，告诉浏览器的解析器用什么规范去解析这个文档

### 6.操作节点(Node)的方法

```
1.appendChild		添加节点
2.removeChild		删除节点
3.replaceChild		替换几点		返回被替换节点
4.hasChildNodes		是否有子节点	   返回布尔值
```



## 三、浏览器

### 1.跨域

```
1.jsonp
	利用浏览器没有跨域限制的漏送，通过script指向要访问的地址，
	并提供一个回调函数去接收通讯时接收的数据。
	但是只限用于get请求
	
2.cors
	这个需要前后端同时支持，前端会自动实现，关键在于后端，服务端
	设置：
		Access-Control-Allow-Origin 就可以开启CORS
		Access-Control-Allow-Headers
		Access-Control-Allow-Methods 哪些方法
	
3.document.domain
	该方式只能用于二级域名相同的情况下，如：a.test.com与b.test.com
	只要给页面添加document.domain='根域名'
```

### 2.浏览器缓存机制

### 3.如何进行网站的性能优化

**三件套+server+图片**

- `content`方面
  - 减少`HTTP`请求：合并文件、`CSS`精灵、`inline Image`
  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名
  - 减少`DOM`元素数量
  - 使用iconfont
  - 删除不必要的元素
- `Server`方面
  - 使用`CDN`
  - 配置`ETag`
  - 对组件使用`Gzip`压缩
- `css`方面
  - 将样式表放到页面顶部
  - 不使用`CSS`表达式
  - 使用`link`，不使用`@import`
  - 避免使用表格
- `Javascript`方面
  - 将脚本放到页面底部 （自上而下的，先优先加载内容和样式，再去解析脚本）
  - 将`javascript`和`css`从外部引入
  - 压缩`javascript`和`css`
  - 删除不需要的脚本
  - 减少`DOM`访问 (重排、重绘，消耗CPU)
- 图片方面
  - 优化图片：根据实际颜色需要选择色深、压缩
  - 优化`css`精灵
  - 不要在`HTML`中拉伸图片

### 4.浏览器渲染UI

```
1.浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree

2.与此同时，进行CSS解析，生成Style Rules

3.接着将DOM Tree与Style Rules合成为 Render Tree

4.接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标

5.随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来

```

### 5.cookie和localSrorage、session、indexDB 的区别

|     特性     |                         cookie                         | session            |       localStorage       | sessionStorage |
| :----------: | :----------------------------------------------------: | ------------------ | :----------------------: | :------------: |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间，或者关闭窗口就消失 | 关闭生命周期就到期 | 除非被清理，否则一直存在 | 页面关闭就清理 |
| 数据存储大小 |                           4K                           | 4k                 |            5M            |       5M       |
| 与服务端通信 |             存放于浏览器，请求的时候会携带             | 存放于服务器       |          不参与          |     不参与     |
|    安全性    |                         不安全                         | 安全               |                          |                |
|     形式     |                         字符串                         | 对象               |                          |                |
|     应用     |                      登录、购物车                      | 登录、购物车       |                          |                |
|     跨域     |                        支持跨域                        | 不支持跨域         |                          |                |

## 五、操作系统

### 1.进程与线程

```
进程是资源分配的基本单位，一个进程就是一个程序，
线程是程序执行最小单位

区别：
	1.多进程是资源分配导的最小单位，	线程是程序执行的最小单位
	2.进程有自己独立的地址空间，		 线程是共享进程的数据的，使用相同的地址空间
	3.进程开销大						线程开销小
```



## 四、GIT

### 1.git 撤销/回滚

```
1.撤销：在本地进行的相关操作，但是并没有提交到远程仓库；
	1.修改，但是未进行add
		1.git checkout fileName 
	2.多个地方进行add，但是只想提交一部分
		1.$ git reset HEAD <filename>
	3.已经commit但是未提交
		$ git commit --amend -m"说明"

2.回滚：已经提交到远程仓库
	1.删除最后一次提交
		1.先git revert HEAD 再git push origin master
		2.先git reset --hard HEAD^再git push origin master -f、
		两者区别：revert是放弃某次提交，生成新提交，有记录
				 reset是将HEAD指针指向未提交，没有记录
```

